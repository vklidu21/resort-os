import Database from 'better-sqlite3'
import path from 'path'
import fs from 'fs'

const DB_PATH = process.env.DATABASE_URL || './data/resort-os.db'
const EXPORT_PATH = process.env.MARKDOWN_EXPORT_PATH || path.resolve(__dirname, '../../../')

interface ExportOptions {
  dbPath?: string
  exportPath?: string
}

export function exportAllMarkdown(opts?: ExportOptions) {
  const dbPath = opts?.dbPath || DB_PATH
  const exportDir = opts?.exportPath || EXPORT_PATH

  if (!fs.existsSync(dbPath)) {
    console.error(`Database not found: ${dbPath}`)
    return
  }

  const db = new Database(dbPath, { readonly: true })
  db.pragma('foreign_keys = ON')

  try {
    exportTasks(db, exportDir)
    exportCompass(db, exportDir)
    exportScorecard(db, exportDir)
    exportMemoryLogs(db, exportDir)
    console.log('Markdown export complete.')
  } finally {
    db.close()
  }
}

function exportTasks(db: Database.Database, exportDir: string) {
  const tasks = db.prepare(`
    SELECT t.*, tm.name as owner_name, tm.type as owner_type, e.name as engine_name, e.emoji as engine_emoji
    FROM tasks t
    LEFT JOIN team_members tm ON t.owner_id = tm.id
    LEFT JOIN engines e ON t.engine_id = e.id
    WHERE t.status != 'archived'
    ORDER BY
      CASE t.priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 ELSE 4 END,
      t.sort_order, t.created_at DESC
  `).all() as any[]

  const high = tasks.filter(t => t.priority === 'high')
  const medium = tasks.filter(t => t.priority === 'medium')
  const low = tasks.filter(t => t.priority === 'low')
  const done = db.prepare(`SELECT * FROM tasks WHERE status = 'done' ORDER BY completed_at DESC LIMIT 20`).all() as any[]

  const statusEmoji: Record<string, string> = {
    inbox: 'ðŸ“¥', backlog: 'ðŸ“‹', in_progress: 'ðŸŸ¡', blocked: 'ðŸš«',
    in_review: 'ðŸ‘€', done: 'âœ…', archived: 'ðŸ“¦',
  }

  function taskLine(t: any): string {
    const emoji = statusEmoji[t.status] || 'ðŸ“‹'
    const owner = t.owner_name ? ` | ${t.owner_type === 'ai' ? 'ðŸ¤–' : 'ðŸ‘¤'} ${t.owner_name}` : ''
    const engine = t.engine_name ? ` | ${t.engine_emoji || ''} ${t.engine_name}` : ''
    return `- [${t.status === 'done' ? 'x' : ' '}] **${t.title}** ${emoji}${engine}${owner}`
  }

  let md = `# Tasks\n\n`
  md += `> Auto-generated by ResortOS. Do not edit manually.\n\n`
  md += `---\n\n`

  if (high.length > 0) {
    md += `## ðŸ”´ HIGH PRIORITY\n\n`
    high.forEach(t => { md += taskLine(t) + '\n' })
    md += '\n'
  }

  if (medium.length > 0) {
    md += `## ðŸŸ¡ MEDIUM PRIORITY\n\n`
    medium.forEach(t => { md += taskLine(t) + '\n' })
    md += '\n'
  }

  if (low.length > 0) {
    md += `## ðŸŸ¢ LOW PRIORITY\n\n`
    low.forEach(t => { md += taskLine(t) + '\n' })
    md += '\n'
  }

  if (done.length > 0) {
    md += `## âœ… Completed\n\n`
    done.forEach((t: any) => {
      md += `- [x] **${t.title}**`
      if (t.completed_at) md += ` (${t.completed_at.split('T')[0]})`
      md += '\n'
    })
    md += '\n'
  }

  md += `---\n\n`
  md += `*Last exported: ${new Date().toISOString()}*\n`

  fs.writeFileSync(path.join(exportDir, 'TASKS.md'), md)
  console.log(`  Exported TASKS.md (${tasks.length} active tasks)`)
}

function exportCompass(db: Database.Database, exportDir: string) {
  const compass = db.prepare(`SELECT * FROM compass WHERE org_id = 1 LIMIT 1`).get() as any
  const org = db.prepare(`SELECT * FROM organizations WHERE id = 1`).get() as any
  const milestones = db.prepare(`SELECT * FROM milestones WHERE org_id = 1 ORDER BY sort_order, target_date`).all() as any[]

  if (!compass && !org) return

  let md = `# Compass\n\n`
  md += `> Auto-generated by ResortOS. Do not edit manually.\n\n`

  if (compass?.north_star) {
    md += `## ðŸŽ¯ North Star\n\n${compass.north_star}\n\n`
  }

  if (compass?.purpose) {
    md += `## ðŸŒŸ Purpose\n\n${compass.purpose}\n\n`
  }

  if (org?.mission) {
    md += `## Mission\n\n${org.mission}\n\n`
  }

  if (org?.values) {
    try {
      const vals = JSON.parse(org.values)
      if (vals.length > 0) {
        md += `## ðŸ’Ž Values\n\n`
        vals.forEach((v: any) => {
          md += `- **${v.name}**${v.description ? ` â€” ${v.description}` : ''}\n`
        })
        md += '\n'
      }
    } catch {}
  }

  if (org?.anti_goals) {
    try {
      const ag = JSON.parse(org.anti_goals)
      if (ag.length > 0) {
        md += `## Anti-Goals\n\n`
        ag.forEach((a: string) => { md += `- ${a}\n` })
        md += '\n'
      }
    } catch {}
  }

  if (compass?.current_reality) {
    try {
      const cr = JSON.parse(compass.current_reality)
      md += `## ðŸ“ Current Reality\n\n`
      if (cr.works?.length > 0) {
        md += `### Co funguje\n\n`
        cr.works.forEach((w: string) => { md += `- ${w}\n` })
        md += '\n'
      }
      if (cr.doesntWork?.length > 0) {
        md += `### Co nefunguje\n\n`
        cr.doesntWork.forEach((w: string) => { md += `- ${w}\n` })
        md += '\n'
      }
    } catch {}
  }

  if (compass?.gaps) {
    try {
      const gaps = JSON.parse(compass.gaps)
      if (gaps.length > 0) {
        md += `## ðŸŽ¯ Gap Analysis\n\n`
        md += `| # | Gap | Priority | Solution |\n|---|-----|----------|----------|\n`
        gaps.forEach((g: any, i: number) => {
          md += `| ${i + 1} | ${g.description} | ${g.priority} | ${g.solution || 'â€”'} |\n`
        })
        md += '\n'
      }
    } catch {}
  }

  if (compass?.strategic_anchors) {
    try {
      const anchors = JSON.parse(compass.strategic_anchors)
      if (anchors.length > 0) {
        md += `## âš“ Strategic Anchors\n\n`
        anchors.forEach((a: string, i: number) => { md += `${i + 1}. ${a}\n` })
        md += '\n'
      }
    } catch {}
  }

  if (milestones.length > 0) {
    md += `## ðŸš€ Milestones 2026\n\n`
    const byQuarter: Record<string, any[]> = {}
    milestones.forEach(m => {
      const q = m.quarter || 'Unassigned'
      if (!byQuarter[q]) byQuarter[q] = []
      byQuarter[q].push(m)
    })
    for (const [quarter, items] of Object.entries(byQuarter)) {
      md += `### ${quarter}\n\n`
      items.forEach((m: any) => {
        const status = m.status === 'done' ? 'x' : ' '
        md += `- [${status}] **${m.title}**`
        if (m.target_date) md += ` (target: ${m.target_date})`
        md += '\n'
      })
      md += '\n'
    }
  }

  md += `---\n\n`
  md += `*Last exported: ${new Date().toISOString()}*\n`

  fs.writeFileSync(path.join(exportDir, 'COMPASS.md'), md)
  console.log(`  Exported COMPASS.md`)
}

function exportScorecard(db: Database.Database, exportDir: string) {
  const metrics = db.prepare(`
    SELECT sm.*, e.name as engine_name, e.emoji as engine_emoji
    FROM scorecard_metrics sm
    LEFT JOIN engines e ON sm.engine_id = e.id
    WHERE sm.org_id = 1
    ORDER BY sm.sort_order
  `).all() as any[]

  if (metrics.length === 0) return

  let md = `# Scorecard\n\n`
  md += `> Auto-generated by ResortOS. Do not edit manually.\n\n`

  const byCategory: Record<string, any[]> = {}
  metrics.forEach(m => {
    const cat = m.category || 'General'
    if (!byCategory[cat]) byCategory[cat] = []
    byCategory[cat].push(m)
  })

  const statusIcon: Record<string, string> = { green: 'ðŸŸ¢', yellow: 'ðŸŸ¡', red: 'ðŸ”´' }
  const trendIcon: Record<string, string> = { up: 'ðŸ“ˆ', down: 'ðŸ“‰', flat: 'âž¡ï¸' }

  for (const [category, items] of Object.entries(byCategory)) {
    md += `## ${category.charAt(0).toUpperCase() + category.slice(1).replace(/_/g, ' ')}\n\n`
    md += `| Metric | Value | Target | Status | Trend |\n|--------|-------|--------|--------|-------|\n`
    items.forEach((m: any) => {
      md += `| ${m.name} | ${m.current_value || 'â€”'} ${m.unit || ''} | ${m.target_value || 'â€”'} | ${statusIcon[m.status] || 'âšª'} | ${trendIcon[m.trend] || 'â€”'} |\n`
    })
    md += '\n'
  }

  md += `---\n\n`
  md += `*Last exported: ${new Date().toISOString()}*\n`

  fs.writeFileSync(path.join(exportDir, 'scorecard.md'), md)
  console.log(`  Exported scorecard.md (${metrics.length} metrics)`)
}

function exportMemoryLogs(db: Database.Database, exportDir: string) {
  const logs = db.prepare(`
    SELECT ml.*, tm.name as author_name
    FROM memory_logs ml
    LEFT JOIN team_members tm ON ml.author_id = tm.id
    WHERE ml.org_id = 1
    ORDER BY ml.date DESC
  `).all() as any[]

  const memoryDir = path.join(exportDir, 'memory')
  if (!fs.existsSync(memoryDir)) fs.mkdirSync(memoryDir, { recursive: true })

  for (const log of logs) {
    const filename = `${log.date}.md`
    fs.writeFileSync(path.join(memoryDir, filename), log.content)
  }

  console.log(`  Exported ${logs.length} memory logs`)
}

// CLI execution
if (require.main === module) {
  const dbPath = process.argv[2] || DB_PATH
  const exportPath = process.argv[3] || EXPORT_PATH
  console.log(`Exporting markdown from ${dbPath} to ${exportPath}...`)
  exportAllMarkdown({ dbPath, exportPath })
}
